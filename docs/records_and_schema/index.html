<!DOCTYPE html><html><head><title>documentation: Records, types and schema</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Marcin Jakubowski" /><meta name="description" content="Read and write Parquet files using Scala" /><meta name="og:image" content="/parquet4s/img/poster.png" /><meta name="image" property="og:image" content="/parquet4s/img/poster.png" /><meta name="og:title" content="documentation: Records, types and schema" /><meta name="title" property="og:title" content="documentation: Records, types and schema" /><meta name="og:site_name" content="documentation" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="Read and write Parquet files using Scala" /><link rel="icon" type="image/png" href="/parquet4s/img/favicon.png" /><meta name="twitter:title" content="documentation: Records, types and schema" /><meta name="twitter:image" content="/parquet4s/img/poster.png" /><meta name="twitter:description" content="Read and write Parquet files using Scala" /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/parquet4s/img/favicon-16x16.png" /><link rel="icon" type="image/png" sizes="32x32" href="/parquet4s/img/favicon-32x32.png" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/parquet4s/highlight/styles/vs.css" /><link rel="stylesheet" href="/parquet4s/css/light-style.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><div id="sidebar-brand"><a href="/parquet4s/" class="brand"><div class="brand-wrapper"></div><span>documentation</span></a><button id="main-toggle" class="sidebar-toggle"><span class="close"></span></button></div><div class="sidebar-nav"> <div class="sidebar-nav-item  "><a href="/parquet4s/docs" title="Introduction" class="">Introduction</a></div> <div class="sidebar-nav-item  "><a href="/parquet4s/docs/quick_start" title="Quick Start" class="">Quick Start</a></div> <div class="sidebar-nav-item  "><a href="/parquet4s/docs/akka" title="Integration with Akka Streams" class="">Integration with Akka Streams</a></div> <div class="sidebar-nav-item  "><a href="/parquet4s/docs/pekko" title="Integration with Pekko Streams" class="">Integration with Pekko Streams</a></div> <div class="sidebar-nav-item  "><a href="/parquet4s/docs/fs2" title="Integration with FS2" class="">Integration with FS2</a></div> <div class="sidebar-nav-item  "><a href="/parquet4s/docs/storage_types" title="Supported storage types" class="">Supported storage types</a></div> <div class="sidebar-nav-item active "><a href="/parquet4s/docs/records_and_schema" title="Records, types and schema" class="active">Records, types and schema</a></div> <div class="sidebar-nav-item  "><a href="/parquet4s/docs/projection" title="Projection" class="">Projection</a></div> <div class="sidebar-nav-item  "><a href="/parquet4s/docs/filtering" title="Filtering" class="">Filtering</a></div> <div class="sidebar-nav-item  "><a href="/parquet4s/docs/partitioning" title="Partitioning" class="">Partitioning</a></div> <div class="sidebar-nav-item  "><a href="/parquet4s/docs/statistics" title="Statistics" class="">Statistics</a></div> <div class="sidebar-nav-item  "><a href="/parquet4s/docs/examples" title="Examples" class="">Examples</a></div> <div class="sidebar-nav-item  "><a href="/parquet4s/docs/migration" title="Migration from 1.x" class="">Migration from 1.x</a></div> <div class="sidebar-nav-item  "><a href="/parquet4s/docs/etl" title="(Experimental) ETL" class="">(Experimental) ETL</a></div> <div class="sidebar-nav-item  "><a href="/parquet4s/docs/protobuf" title="(Experimental) Protobuf with ScalaPB" class="">(Experimental) Protobuf with ScalaPB</a></div> <div class="sidebar-nav-item  "><a href="/parquet4s/docs/sponsors" title="Distinguished Sponsors" class="">Distinguished Sponsors</a></div></div></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li class="search-nav"><div id="search-dropdown"><label><i class="fa fa-search"></i>Search</label><input id="search-bar" type="text" placeholder="Enter keywords here..." onclick="displayToggleSearch(event)" /><ul id="search-dropdown-content" class="dropdown dropdown-content"></ul></div></li><li id="gh-eyes-item" class="hidden-xs to-uppercase"><a href="https://github.com/mjakubowski84/parquet4s" target="_blank" rel="noopener noreferrer"><i class="fa fa-eye"></i><span>Watchers<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs to-uppercase"><a href="https://github.com/mjakubowski84/parquet4s" target="_blank" rel="noopener noreferrer"><i class="fa fa-star-o"></i><span>Stars<span id="stars" class="label label-default">--</span></span></a></li></ul></div></div></div></div><div id="content" data-github-owner="mjakubowski84" data-github-repo="parquet4s"><div class="content-wrapper"><section><h1 id="records">Records</h1>

<p>A data entry in Parquet is called a <code class="language-plaintext highlighter-rouge">record</code>. The record can represent a <code class="language-plaintext highlighter-rouge">row</code> of data, or it can be a nested complex field in another <code class="language-plaintext highlighter-rouge">row</code>. Other types of record are a <code class="language-plaintext highlighter-rouge">map</code> and a <code class="language-plaintext highlighter-rouge">list</code>. Stored data must be organised in <code class="language-plaintext highlighter-rouge">row</code>s. Neither primitive type nor <code class="language-plaintext highlighter-rouge">map</code> or <code class="language-plaintext highlighter-rouge">list</code> are allowed as a root data type.
In Parquet4s those concepts are represented by types that extend <code class="language-plaintext highlighter-rouge">ParquetRecord</code>: <code class="language-plaintext highlighter-rouge">RowParquetRecord</code>, <code class="language-plaintext highlighter-rouge">MapParquetRecord</code> and <code class="language-plaintext highlighter-rouge">ListParquetRecord</code>. <code class="language-plaintext highlighter-rouge">ParquetRecord</code> extends Scala’s immutable <code class="language-plaintext highlighter-rouge">Iterable</code> and allows iteration (next to many other operations) over its content: fields of a <code class="language-plaintext highlighter-rouge">row</code>, key-value entries of a <code class="language-plaintext highlighter-rouge">map</code> and elements of a <code class="language-plaintext highlighter-rouge">list</code>. When using the library you have the option to use those data structures directly, or you can use regular Scala classes that are encoded/decoded by instances of <code class="language-plaintext highlighter-rouge">ValueCodec</code> to/from <code class="language-plaintext highlighter-rouge">ParqutRecord</code>.</p>

<p>Parquet organizes row records into <code class="language-plaintext highlighter-rouge">pages</code> and pages into <code class="language-plaintext highlighter-rouge">row groups</code>. Row groups and pages are data blocks accompanied by metadata such as <code class="language-plaintext highlighter-rouge">statistics</code> and <code class="language-plaintext highlighter-rouge">dictionaries</code>. Metadata is leveraged during <a href="/parquet4s/docs/filtering/">filtering</a> - so that some data blocks are skipped during reading if the metadata proves that the related data does not match provided filter predicate.</p>

<p>For more information about data structures in Parquet please refer to the <a href="https://parquet.apache.org/documentation/latest/">official documentation</a>.</p>

<h1 id="schema">Schema</h1>

<p>Each Parquet file contains the schema of the data it stores. The schema defines the structure of records, names and types of fields, optionality, etc. Schema is required for writing Parquet files and can be optionally used during reading for <a href="/parquet4s/docs/projection/">projection</a>.</p>

<p>The official Parquet library, that Parquet4s is based on, defines the schema in Java type called <code class="language-plaintext highlighter-rouge">MessageType</code>. As it is quite tedious to define the schema and map it to your data types, Parquet4s comes with a handy mechanism that derives it automatically from Scala case classes. Please follow this documentation to learn which Scala types are supported out of the box and how to define custom encoders and decoders.</p>

<p>If you do not wish to map the schema of your data to Scala case classes, then Parquet4s allows you to stick to generic records, that is, to the aforementioned subtypes of <code class="language-plaintext highlighter-rouge">ParquetRecord</code>. Still, you must provide <code class="language-plaintext highlighter-rouge">MessageType</code> during writing. If you do not provide it during reading, then Parquet4s uses the schema stored in a file, and all its content is read.</p>

<h2 id="supported-types">Supported types</h2>

<h3 id="primitive-types">Primitive types</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Type</th>
      <th style="text-align: center">Reading and Writing</th>
      <th style="text-align: center">Filtering</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Int</td>
      <td style="text-align: center">☑</td>
      <td style="text-align: center">☑</td>
    </tr>
    <tr>
      <td style="text-align: left">Long</td>
      <td style="text-align: center">☑</td>
      <td style="text-align: center">☑</td>
    </tr>
    <tr>
      <td style="text-align: left">Byte</td>
      <td style="text-align: center">☑</td>
      <td style="text-align: center">☑</td>
    </tr>
    <tr>
      <td style="text-align: left">Short</td>
      <td style="text-align: center">☑</td>
      <td style="text-align: center">☑</td>
    </tr>
    <tr>
      <td style="text-align: left">Boolean</td>
      <td style="text-align: center">☑</td>
      <td style="text-align: center">☑</td>
    </tr>
    <tr>
      <td style="text-align: left">Char</td>
      <td style="text-align: center">☑</td>
      <td style="text-align: center">☑</td>
    </tr>
    <tr>
      <td style="text-align: left">Float</td>
      <td style="text-align: center">☑</td>
      <td style="text-align: center">☑</td>
    </tr>
    <tr>
      <td style="text-align: left">Double</td>
      <td style="text-align: center">☑</td>
      <td style="text-align: center">☑</td>
    </tr>
    <tr>
      <td style="text-align: left">BigDecimal</td>
      <td style="text-align: center">☑</td>
      <td style="text-align: center">☑</td>
    </tr>
    <tr>
      <td style="text-align: left">java.time.LocalDateTime [*with INT96]</td>
      <td style="text-align: center">☑</td>
      <td style="text-align: center">☒</td>
    </tr>
    <tr>
      <td style="text-align: left">java.time.LocalDateTime [*with INT64]</td>
      <td style="text-align: center">☑</td>
      <td style="text-align: center">☑</td>
    </tr>
    <tr>
      <td style="text-align: left">java.time.Instant [*with INT96]</td>
      <td style="text-align: center">☑</td>
      <td style="text-align: center">☒</td>
    </tr>
    <tr>
      <td style="text-align: left">java.time.Instant [*with INT64]</td>
      <td style="text-align: center">☑</td>
      <td style="text-align: center">☑</td>
    </tr>
    <tr>
      <td style="text-align: left">java.time.LocalDate</td>
      <td style="text-align: center">☑</td>
      <td style="text-align: center">☑</td>
    </tr>
    <tr>
      <td style="text-align: left">java.sql.Timestamp [*with INT96]</td>
      <td style="text-align: center">☑</td>
      <td style="text-align: center">☒</td>
    </tr>
    <tr>
      <td style="text-align: left">java.sql.Timestamp [*with INT64]</td>
      <td style="text-align: center">☑</td>
      <td style="text-align: center">☑</td>
    </tr>
    <tr>
      <td style="text-align: left">java.sql.Date</td>
      <td style="text-align: center">☑</td>
      <td style="text-align: center">☑</td>
    </tr>
    <tr>
      <td style="text-align: left">Array[Byte]</td>
      <td style="text-align: center">☑</td>
      <td style="text-align: center">☑</td>
    </tr>
  </tbody>
</table>

<p>*) You can change the default format of the timestamp column from INT96 to INT64 by importing type classes:</p>

<ul>
  <li>INT64 micros format: <code class="language-plaintext highlighter-rouge">import com.github.mjakubowski84.parquet4s.TimestampFormat.Implicits.Micros._</code></li>
  <li>INT64 mills format: <code class="language-plaintext highlighter-rouge">import com.github.mjakubowski84.parquet4s.TimestampFormat.Implicits.Millis._</code></li>
  <li>INT64 nanos format: <code class="language-plaintext highlighter-rouge">import com.github.mjakubowski84.parquet4s.TimestampFormat.Implicits.Nanos._</code></li>
</ul>

<p>The imports contain type classes supporting projection, filtering and writing.</p>

<h3 id="complex-types">Complex Types</h3>

<p>Complex types can be arbitrarily nested.</p>

<ul>
  <li>Option</li>
  <li>List</li>
  <li>Seq</li>
  <li>Vector</li>
  <li>Set</li>
  <li>Array - An array of bytes is treated as primitive binary</li>
  <li>Map - <strong>Key must be of primitive type</strong>, only the <strong>immutable</strong> version.</li>
  <li>Any Scala collection that has Scala collection <code class="language-plaintext highlighter-rouge">Factory</code> (in 2.12 it is derived from <code class="language-plaintext highlighter-rouge">CanBuildFrom</code>). Refers to both mutable and immutable collections. Collection must be bounded only by one type of element - because of that Map is supported only in the immutable version.</li>
  <li><em>Any case class</em></li>
</ul>

<h3 id="custom-types">Custom Types</h3>

<p>Parquet4s is built using Scala’s type class system. That allows you to extend Parquet4s by defining your own implementations of type classes.</p>

<p>For example, you may define a codec for your own type so that it can be read from or written to Parquet. Assuming that you have your own type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">CustomType</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</code></pre></div></div>

<p>You want to save it as optional <code class="language-plaintext highlighter-rouge">Int</code>. In order to achieve that you have to define a codec:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">com.github.mjakubowski84.parquet4s.</span><span class="o">{</span><span class="nc">OptionalValueCodec</span><span class="o">,</span> <span class="nc">IntValue</span><span class="o">,</span> <span class="nc">Value</span><span class="o">,</span> <span class="nc">ValueCodecConfiguration</span><span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">CustomType</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">customTypeCodec</span><span class="k">:</span> <span class="kt">OptionalValueCodec</span><span class="o">[</span><span class="kt">CustomType</span><span class="o">]</span> <span class="k">=</span> 
  <span class="k">new</span> <span class="nc">OptionalValueCodec</span><span class="o">[</span><span class="kt">CustomType</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">protected</span> <span class="k">def</span> <span class="nf">decodeNonNull</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Value</span><span class="o">,</span> <span class="n">configuration</span><span class="k">:</span> <span class="kt">ValueCodecConfiguration</span><span class="o">)</span><span class="k">:</span> <span class="kt">CustomType</span> <span class="o">=</span>
      <span class="n">value</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">IntValue</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">CustomType</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="k">override</span> <span class="k">protected</span> <span class="k">def</span> <span class="nf">encodeNonNull</span><span class="o">(</span><span class="n">data</span><span class="k">:</span> <span class="kt">CustomType</span><span class="o">,</span> <span class="n">configuration</span><span class="k">:</span> <span class="kt">ValueCodecConfiguration</span><span class="o">)</span><span class="k">:</span> <span class="kt">Value</span> <span class="o">=</span>
      <span class="nc">IntValue</span><span class="o">(</span><span class="nv">data</span><span class="o">.</span><span class="py">i</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ValueCodec</code> composes <code class="language-plaintext highlighter-rouge">ValueEncoder</code> and <code class="language-plaintext highlighter-rouge">ValueDecoder</code>, so if you need only to read or only to write your type, then it is enough if you implement only one of them.</p>

<p>Additionally, if you want to write your custom type, you have to define the schema for it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">org.apache.parquet.schema.</span><span class="o">{</span><span class="nc">LogicalTypeAnnotation</span><span class="o">,</span> <span class="nc">PrimitiveType</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">com.github.mjakubowski84.parquet4s.TypedSchemaDef</span>
<span class="k">import</span> <span class="nn">com.github.mjakubowski84.parquet4s.</span><span class="o">{</span><span class="nc">LogicalTypes</span><span class="o">,</span> <span class="nc">SchemaDef</span><span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">CustomType</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">customTypeSchema</span><span class="k">:</span> <span class="kt">TypedSchemaDef</span><span class="o">[</span><span class="kt">CustomType</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">SchemaDef</span><span class="o">.</span><span class="py">primitive</span><span class="o">(</span>
    <span class="n">primitiveType</span> <span class="k">=</span> <span class="nv">PrimitiveType</span><span class="o">.</span><span class="py">PrimitiveTypeName</span><span class="o">.</span><span class="py">INT32</span><span class="o">,</span>
    <span class="n">required</span> <span class="k">=</span> <span class="kc">false</span><span class="o">,</span>
    <span class="n">logicalTypeAnnotation</span> <span class="k">=</span> <span class="nc">Option</span><span class="o">(</span><span class="nv">LogicalTypes</span><span class="o">.</span><span class="py">Int32Type</span><span class="o">)</span>
  <span class="o">).</span><span class="py">typed</span><span class="o">[</span><span class="kt">CustomType</span><span class="o">]</span>
</code></pre></div></div>

<p>In order to filter by a field of a custom type <code class="language-plaintext highlighter-rouge">T</code> you have to implement <code class="language-plaintext highlighter-rouge">FilterCodec[T]</code> type class.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">com.github.mjakubowski84.parquet4s.FilterCodec</span>
<span class="k">import</span> <span class="nn">org.apache.parquet.filter2.predicate.Operators.IntColumn</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">CustomType</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">customFilterCodec</span><span class="k">:</span> <span class="kt">FilterCodec</span><span class="o">[</span><span class="kt">CustomType</span>, <span class="kt">java.lang.Integer</span>, <span class="kt">IntColumn</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">FilterCodec</span><span class="o">[</span><span class="kt">CustomType</span>, <span class="kt">java.lang.Integer</span>, <span class="kt">IntColumn</span><span class="o">](</span>
    <span class="n">encode</span> <span class="k">=</span> <span class="o">(</span><span class="n">customType</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">customType</span><span class="o">.</span><span class="py">i</span><span class="o">,</span>
    <span class="n">decode</span> <span class="k">=</span> <span class="o">(</span><span class="n">integer</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span>    <span class="k">=&gt;</span> <span class="nc">CustomType</span><span class="o">(</span><span class="n">integer</span><span class="o">)</span>
  <span class="o">)</span>
</code></pre></div></div>

<h1 id="using-generic-records-directly">Using generic records directly</h1>

<p>Parquet4s allows you to choose to use generic records explicitly from the level of API in each module of the library. But you can also use typed API and define <code class="language-plaintext highlighter-rouge">RowParquetRecord</code> as your data type. Parquet4s contains type classes for encoding, decoding and schema provisioning for <code class="language-plaintext highlighter-rouge">RowParquetRecord</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">com.github.mjakubowski84.parquet4s.</span><span class="o">{</span><span class="nc">ParquetReader</span><span class="o">,</span> <span class="nc">ParquetWriter</span><span class="o">,</span> <span class="nc">Path</span><span class="o">,</span> <span class="nc">RowParquetRecord</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">org.apache.parquet.schema.MessageType</span>

<span class="c1">// both reads are equivalent</span>
<span class="nv">ParquetReader</span><span class="o">.</span><span class="py">generic</span><span class="o">.</span><span class="py">read</span><span class="o">(</span><span class="nc">Path</span><span class="o">(</span><span class="s">"file.parquet"</span><span class="o">))</span>
<span class="nv">ParquetReader</span><span class="o">.</span><span class="py">as</span><span class="o">[</span><span class="kt">RowParquetRecord</span><span class="o">].</span><span class="py">read</span><span class="o">(</span><span class="nc">Path</span><span class="o">(</span><span class="s">"file.parquet"</span><span class="o">))</span>

<span class="k">val</span> <span class="nv">data</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">RowParquetRecord</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="c1">// when using generic record you need to define the schema on your own</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">schema</span><span class="k">:</span> <span class="kt">MessageType</span> <span class="o">=</span> <span class="o">???</span>

<span class="c1">// both writes are equivalent</span>
<span class="nc">ParquetWriter</span>
  <span class="o">.</span><span class="py">generic</span><span class="o">(</span><span class="n">schema</span><span class="o">)</span> <span class="c1">// schema is passed explicitly</span>
  <span class="o">.</span><span class="py">writeAndClose</span><span class="o">(</span><span class="nc">Path</span><span class="o">(</span><span class="s">"file.parquet"</span><span class="o">),</span> <span class="n">data</span><span class="o">)</span>
<span class="nc">ParquetWriter</span>
  <span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">RowParquetRecord</span><span class="o">]</span> <span class="c1">// schema is passed implicitly</span>
  <span class="o">.</span><span class="py">writeAndClose</span><span class="o">(</span><span class="nc">Path</span><span class="o">(</span><span class="s">"file.parquet"</span><span class="o">),</span> <span class="n">data</span><span class="o">)</span>
</code></pre></div></div>
</section></div></div></div></div><script src="/parquet4s/highlight/highlight.pack.js"></script><script src="/parquet4s/lunr/lunr.js"></script><script>
// For all code blocks, copy the language from the containing div
// to the inner code tag (where hljs expects it to be)
const langPrefix = 'language-';
document.querySelectorAll(`div[class^='${langPrefix}']`).forEach(function(div) {
  div.classList.forEach(function(cssClass) {
    if (cssClass.startsWith(langPrefix)) {
      const lang = cssClass.substring(langPrefix.length);
      div.querySelectorAll('pre code').forEach(function(code) {
        code.classList.add(lang);
      });
    }
  });
});

hljs.configure({languages:['scala','java','bash']});
hljs.initHighlightingOnLoad();
      </script><script>console.info('\x57\x65\x62\x73\x69\x74\x65\x20\x62\x75\x69\x6c\x74\x20\x77\x69\x74\x68\x3a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x5f\x20\x20\x20\x20\x5f\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x20\x5f\x5f\x0a\x20\x20\x20\x5f\x5f\x5f\x5f\x5f\x2f\x20\x2f\x5f\x20\x20\x2f\x20\x2f\x5f\x20\x20\x20\x20\x20\x20\x5f\x5f\x5f\x5f\x20\x5f\x5f\x5f\x20\x20\x28\x5f\x29\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x20\x20\x5f\x5f\x5f\x5f\x5f\x28\x5f\x29\x20\x2f\x5f\x5f\x5f\x5f\x20\x20\x5f\x5f\x5f\x5f\x5f\x0a\x20\x20\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x5c\x2f\x20\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x60\x5f\x5f\x20\x5c\x2f\x20\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x5c\x2f\x20\x5f\x5f\x5f\x2f\x20\x2f\x20\x5f\x5f\x2f\x20\x5f\x20\x5c\x2f\x20\x5f\x5f\x5f\x2f\x0a\x20\x28\x5f\x5f\x20\x20\x29\x20\x2f\x5f\x2f\x20\x2f\x20\x2f\x5f\x2f\x5f\x5f\x5f\x5f\x5f\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x5f\x5f\x2f\x20\x2f\x20\x20\x2f\x20\x2f\x5f\x2f\x20\x28\x5f\x5f\x20\x20\x29\x20\x2f\x20\x2f\x5f\x2f\x20\x20\x5f\x5f\x28\x5f\x5f\x20\x20\x29\x0a\x2f\x5f\x5f\x5f\x5f\x2f\x5f\x2e\x5f\x5f\x5f\x2f\x5c\x5f\x5f\x2f\x20\x20\x20\x20\x20\x2f\x5f\x2f\x20\x2f\x5f\x2f\x20\x2f\x5f\x2f\x5f\x2f\x5c\x5f\x5f\x5f\x2f\x5f\x2f\x20\x20\x20\x5c\x5f\x5f\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x2f\x5f\x2f\x5c\x5f\x5f\x2f\x5c\x5f\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x2f\x0a\x0a\x68\x74\x74\x70\x73\x3a\x2f\x2f\x34\x37\x64\x65\x67\x2e\x67\x69\x74\x68\x75\x62\x2e\x69\x6f\x2f\x73\x62\x74\x2d\x6d\x69\x63\x72\x6f\x73\x69\x74\x65\x73')</script><script src="/parquet4s/js/search.js"></script><script src="/parquet4s/js/docs.js"></script></body></html>